//! Types related to the failure conditions of the parsing process.
//!
//! The parsing failure can be indicated by [`ParseError`], [`UnrecognizedToken`], or
//! [`ParseFailure`]. See [`Parser`](super::Parser) for documentation on when each
//! of these types should be used.

use crate::tokens::{Token, TokenStream, UnbalancedParenthesis};
use std::borrow::Cow;
use std::fmt;

#[derive(Debug, PartialEq)]
enum ParseErrorVariant<'a> {
    Invalid {
        token: Token<'a>,
        message: Option<Cow<'static, str>>,
    },
    Unknown(Token<'a>),
    TokenRequired,
    UnbalancedParenthesis,
    Custom(Cow<'static, str>),
}

/// Unrecoverable parsing error
///
/// This type represent a parsing error that caused by the invalid data. Usually this error is
/// propagated up the call chain and is returned to the parsing initiator. This error may
/// optionally contain the name of the type (in the user-readable format) parsing of which has
/// caused the error.
#[derive(Debug, PartialEq)]
pub struct ParseError<'a> {
    variant: ParseErrorVariant<'a>,
    expected: Option<Cow<'static, str>>,
}

impl<'a> ParseError<'a> {
    /// Creates a new error representing a case when a token is unrecognized and the parser cannot
    /// pass it to the parent parser due to the current value being only partially parsed.
    ///
    /// Calling this method is equivalent to converting [`UnrecognizedToken`] into `ParseError`.
    pub fn unknown(token: Token<'a>) -> Self {
        ParseError {
            variant: ParseErrorVariant::Unknown(token),
            expected: None,
        }
    }

    /// Creates a new error representing a case when a text token is required but one isn't
    /// present.
    pub fn token_required() -> Self {
        ParseError {
            variant: ParseErrorVariant::TokenRequired,
            expected: None,
        }
    }

    /// Creates a new error representing a punctuation error: a parenthesis is opened or closed
    /// when one was not expected.
    ///
    /// Calling this method is equivalent to converting [`UnbalancedParenthesis`] error into
    /// `ParseError`.
    pub fn unbalanced_parenthesis() -> Self {
        ParseError {
            variant: ParseErrorVariant::UnbalancedParenthesis,
            expected: None,
        }
    }

    /// Creates a new error representing a failure to parse a token or multiple tokens. This error
    /// occurs when the token content is invalid, for example a token contains non-numeric
    /// characters if the number is required.
    ///
    /// This function takes a [`Token`] that the parser failed to handle and an optional message
    /// text.
    pub fn invalid(token: Token<'a>, message: Option<Cow<'static, str>>) -> Self {
        ParseError {
            variant: ParseErrorVariant::Invalid { token, message },
            expected: None,
        }
    }

    /// Creates an error with a custom message. No semantics is associated with this error, it can
    /// be used when neither of the other error types is applicable, for example when performing
    /// validation.
    pub fn custom(message: impl Into<Cow<'static, str>>) -> Self {
        ParseError {
            variant: ParseErrorVariant::Custom(message.into()),
            expected: None,
        }
    }

    /// Attaches an expected type in a human readable format that the parser was trying to handle
    /// when the error occurred.
    ///
    /// This value is reflected in the string representation of the `ParseError` generated by the
    /// [`Display`](std::fmt::Display) trait.
    pub fn expected(mut self, expected: impl Into<Cow<'static, str>>) -> Self {
        self.expected = Some(expected.into());
        self
    }
}

impl<'a> From<UnbalancedParenthesis> for ParseError<'a> {
    fn from(_: UnbalancedParenthesis) -> Self {
        ParseError::unbalanced_parenthesis()
    }
}

impl<'a> std::error::Error for ParseError<'a> {}

impl<'a> fmt::Display for ParseError<'a> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match &self.variant {
            ParseErrorVariant::Invalid { token, message } => {
                f.write_fmt(format_args!("cannot parse {}", token.into_raw_lexeme()))?;
                if let Some(message) = message {
                    f.write_fmt(format_args!(" ({})", message))?;
                }
            }
            ParseErrorVariant::Unknown(Token::Text(text)) => {
                f.write_fmt(format_args!("unrecognized token: {}", text))?;
            }
            ParseErrorVariant::Unknown(Token::Attribute(attr)) => {
                f.write_fmt(format_args!("unrecognized attribute: {}", attr))?;
            }
            ParseErrorVariant::TokenRequired => f.write_str("not enough tokens")?,
            ParseErrorVariant::UnbalancedParenthesis => f.write_str("unbalanced parenthesis")?,
            ParseErrorVariant::Custom(message) => f.write_str(message)?,
        }

        if let Some(expected) = &self.expected {
            f.write_fmt(format_args!(", expected {}", expected))?;
        }
        Ok(())
    }
}

/// Value's failed parsing result
///
/// The parsing operation for any value may result in one of three outcomes:
/// 1. The value was parsed successfully
/// 2. The parsing failed due to an error. The parsing process cannot recover from this type of a
///    failure, it terminates immediately
/// 3. The parser does not recognize the first token: it is either an attribute that the parser
///    does not recognize (it may still be recognized and handled by the parent parser) or an
///    unknown enum discriminator.
///
/// The last two outcomes are represented by the `ParseFailure` enum (`Error` and `Unrecognized`
/// variants respectively).
#[derive(Debug)]
pub enum ParseFailure<'a> {
    /// The parsing failed with an unrecoverable error
    Error(ParseError<'a>),

    /// The token is not recognized by the parser
    Unrecognized(UnrecognizedToken<'a>),
}

impl<'a> ParseFailure<'a> {
    /// Returns a reference to the [`ParseError`] if this `ParseFailure` corresponds to an error or
    /// `None` otherwise.
    pub fn as_error(&self) -> Option<&ParseError<'a>> {
        if let ParseFailure::Error(error) = self {
            Some(error)
        } else {
            None
        }
    }

    /// Returns a reference to the [`UnrecognizedToken`] if this `ParseFailure` corresponds to a
    /// failure due to an unrecognized tokens or `None` otherwise.
    pub fn as_unrecognized(&self) -> Option<&UnrecognizedToken<'a>> {
        if let ParseFailure::Unrecognized(unrecognized) = self {
            Some(unrecognized)
        } else {
            None
        }
    }
}

impl<'a, E: Into<ParseError<'a>>> From<E> for ParseFailure<'a> {
    fn from(error: E) -> Self {
        ParseFailure::Error(error.into())
    }
}

/// Parsing failure due to an unrecognized attribute or enum descriminator.
///
/// This struct consist of the token that was not recognized and a [`TokenStream`] representing the
/// remaining stream. These values should come from the single call to [`TokenStream::take`].
#[derive(Debug)]
pub struct UnrecognizedToken<'a> {
    token: Token<'a>,
    remaining: TokenStream<'a>,
}

impl<'a> UnrecognizedToken<'a> {
    /// Create a new `UnrecognizedToken` instance from a token that was not recognized by the
    /// parser and the remaining tokens stream.
    pub fn new(token: Token<'a>, remaining: TokenStream<'a>) -> Self {
        UnrecognizedToken { token, remaining }
    }

    /// Returns a token that was not recognized by the parser.
    pub fn token(&self) -> Token<'a> {
        self.token
    }

    /// Returns a token stream that represents tokens that follow the `token`.
    pub fn remaining(&self) -> &TokenStream<'a> {
        &self.remaining
    }

    /// Converts this `UnrecognizedToken` into a [`ParseError`].
    pub fn into_error(self) -> ParseError<'a> {
        ParseError::unknown(self.token())
    }
}

impl<'a> From<UnrecognizedToken<'a>> for ParseFailure<'a> {
    fn from(unrecognized: UnrecognizedToken<'a>) -> Self {
        ParseFailure::Unrecognized(unrecognized)
    }
}

#[cfg(test)]
mod tests {
    use super::ParseError;
    use crate::testing::token;

    mod error_display {
        use super::*;

        #[test]
        fn invalid() {
            let error = ParseError::invalid(token!("<<token>>"), None).expected("integer");
            assert_eq!(
                &error.to_string(),
                "cannot parse \"<<token>>\", expected integer"
            );
        }

        #[test]
        fn invalid_with_message() {
            let error = ParseError::invalid(token!("<<token>>"), Some("not a number".into()));
            assert_eq!(
                &error.to_string(),
                "cannot parse \"<<token>>\" (not a number)"
            );
        }

        #[test]
        fn unknown_attribute() {
            let error = ParseError::unknown(token!(--"<<attr>>"));
            assert_eq!(&error.to_string(), "unrecognized attribute: \"<<attr>>\"");
        }

        #[test]
        fn unknown_text() {
            let error = ParseError::unknown(token!("<<text>>"));
            assert_eq!(&error.to_string(), "unrecognized token: \"<<text>>\"");
        }
    }
}
